# Introduction

  Industrial control systems orchestrate the infrastructure that our society often takes for granted. They pump millions of gallons of water into municipal reservoirs, regulate electricity that flows through power grids, and sequence automated conveyors that keep supply chains going. The devices at the heart of these operations: programmable logic controllers (PLCs), distributed control systems (DCS), field sensors, actuators, and more belong to what is known as operational technology (OT). While the proliferation of personal computers and the growth of business-oriented information technology introduced robust authentication, encryption, and patching practices, operational technology prioritizes characteristics such as determinism and longevity. Consequently, many industrial protocols were created at a time when zero-trust principles were not standard practice and network segments were always air-gapped.

  The Modbus protocol is a perfect example of this legacy design philosophy. Introduced by Modicon in 1979 as a request-response serial protocol, Modbus became the lingua franca for industrial automation because it was inexpensive and easy to troubleshoot. The simplicity and minimalism of this protocol became both its strength and its weakness. Modbus was later encapsulated inside TCP/IP but still retained the original semantics: a master transmits an unencrypted command and a slave responds with unauthenticated data. There is no handshake or validation. This means a threat actor who can inject a forged frame has the power to alter vital processes, which can have catastrophic effects.
  
  Industrial security incidents over the last two decades illustrate how thin the divide between cyber and physical consequences can be. Stuxnet, found in 2010, manipulated PLC logic to cause nuclear centrifuges to spin at abnormal frequencies beyond what is considered safe. In both 2015 and 2016, threat actors used fraudulent control messages to open circuit breakers in Ukraine, which resulted in thousands of residents living in hours of darkness. Lastly, the 2017 Triton malware attempted to disable a petrochemical plant's safety instrumented system. These attacks all follow a common pattern: gain a foothold on the network, create traffic that the equipment assumes is real, and translate digital commands into mechanical or chemical change.

  When reading about these attacks, they can sound a bit abstract. A person may learn that a "Write Single Coil" packet contains a function code of 05 and that a value of 0xFF00 energizes a bit, but the significance of these commands simply does not register until something in the physical environment changes. The CPS Modbus Security Lab presented in this repository bridges that gap by attaching a simple electronics setup to real network packets. A Raspberry Pi serves simultaneously as a Modbus-TCP slave, an Intrusion Detection System host, and an I/O board. By connecting the Pi's GPIO 17 pin to an LED through a 220-ohm resistor, we gain an immediate, low-risk indicator of whether a Modbus command has succeeded. When a crafted frame with the correct transaction ID and register reference reaches the socket, the LED flashes; when the register value is toggled again, the LED turns off. This simple visual feedback demonstrates the same principles used in controlling industrial systems like robotic arms or valve actuators.

  Since physical actions alone won't grant effective teaching, the same Pi also executes Suricata, an open-source, rule-driven IDS/IPS capable of parsing Modbus traffic. Custom signatures watch for attack patterns such as write commands that could indicate a flooding attempt or repeated payloads hinting at a replay. When Suricata recognizes an attack, it logs a time-stamped JSON event. We can then observe both sides of the defender and the attacker.

