# Technical Background

  Industrial automation traffic often flows across the same copper wires and 802.11 frames that carry ordinary office data, yet the protocols embedded in that traffic obey rules written before the public Internet existed. Modbus, made in 1979, was later repackaged inside TCP/IP so that controllers could be reached without all the dedicated cabling. This created a peculiar hybrid: a protocol that has the delivery of TCP while retaining a payload structure that expects every device to be trusted and deterministic. 

  A standard Modbus/TCP frame begins with a seven byte Modbus Application Protocol (MBAP) header. The first two octets make the Transaction Identifier, which is a value chosen by the client so it can match responses to requests when multiple commands are pipelined across a single connection. The next two octets are the Protocol Identifier and are always set to 0000. Two more octets express the length of the subsequent bytes, including the Unit Identifier and the Protocol Data Unit (PDU). The final octet in the header is the Unit Identifier, which historically mapped to a RTU device address on a multi-drop serial line. In pure Ethernet deployments, the field is usually left at 0xFF or 0x11 as placeholders. 

  Directly after the header comes the PDU. Its first byte is the Function Code, which instructs the server what logical action to perform. The lab server recognizes Function Codes 01 and 03 for reading coils and holding registers and Function Codes 05 and 06 for writing a single coil or register. For a "Write Single Coil" request the PDU contains four additional octets: two for the target coil address and two for the value. A value of 0xFF00 represnts logical "ON" and 0x0000 represnts logical "OFF". Because the protocol does not embed a cryptographic checksum or something similar, any person capable of transmitting packets to port 502 can replay or modify these values with no challenge. 

  To illustrate the wire format, consider the packet captured during an operator-initiated coil activation: 00 01 00 06 11 05 00 00 FF 00. The transaction starts with the identifier 0001, the protocol field 0000, and a length of six bytes. The Unit Identifier is 11, followed by Function Code 05 (Write Single Coil). The target address is 0000, and the payload FF00 activates the LED to a lit state. The server replies with the same twelve-byte sequence to confirm acceptance.
  
  Within the lab the server is implemented as a raw-socket Python daemon rather than via a library such as PyModbus. Direct socket control eliminates third party abstractions that might mask protocol details. The attack scripts use Scapy to parse the MBAP header and PDU directly from captured packets; modifying two bytes in the PDU is sufficient to invert the logical state of the LED or to construct a timing based convert chanel that flashes a particular sequence, such as "SOS". 

  Security weaknesses in Modbus/TCP are well documented. There is no built-in authentication, privacy, or integrity. Every request is implicitly trusted, and error responses just raise exception codes without halting the session. In a production plant, these can be mitigated by using IDS that are protocol aware or out-of-band firewalls, for example. This lab adopts the former by running Suricata on the same Raspberry Pi that hosts the server. Custom rules employ the modbus keyword to match Function Codes and apply detection_filter directives.
